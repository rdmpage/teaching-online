<?php

require_once('treelib/node_iterator.php');
require_once('treelib/svg.php');
require_once('treelib/tree_drawer.php');
require_once('treelib/tree_drawer.php');


//--------------------------------------------------------------------------------------------------


$tree_num = 0;

if (isset($_GET['tree_num']))
{
	$tree_num = $_GET['tree_num'];
}

$next = $tree_num + 1;

$sample = 500;

$filename = 'hominid.nex.run1.t';

$file_handle = fopen($filename, "r");

$count = 0;
$skip = 10;
while (!feof($file_handle)) 
{
	$line = trim(fgets($file_handle));
	
	//echo "$count $tree_num $skip\n";
	
	if ($count == ($tree_num + $skip))
	{
		$newick = preg_replace('/\s+tree gen.\d+ = [&U]\s+/', '', $line);
		
		//echo $newick;

		/*
		
		
		$newick = '((5:1.000000e-01,2:1.000000e-01):1.000000e-01,(4:1.000000e-01,3:1.000000e-01):1.000000e-01,1:1.000000e-01);';
		
		$newick = '(((4:6.385266e-02,3:5.611966e-02):1.157026e-02,2:2.869684e-02):5.329008e-02,5:9.060966e-02,1:1.194653e-01);';
		
		*/
		
		// Read tree
		$t = new Tree();
		$t->Parse($newick);
		
		// labels
		
		$ni = new NodeIterator ($t->GetRoot());
		$q = $ni->Begin();
		while ($q != NULL)
		{	
			if ($q->IsLeaf ())
			{
				// Get children
				switch($q->GetLabel())
				{
					case '2':
						$q->SetLabel('human');
						break;
					case '3':
						$q->SetLabel('chimp');
						break;
					case '4':
						$q->SetLabel('gorilla');
						break;
					case '5':
						$q->SetLabel('orang');
						break;
					case '1':
						$q->SetLabel('gibbon');
						break;
	
						
					default:
						break;
				}
			}
			$q = $ni->Next();
		}
	
	// draw...
	
		$t->BuildWeights($t->GetRoot());
		
		
		$height = 400;
		$width = 400;
		$tree_width 	= $width - 100;
		
		// Drawing properties
		$attr = array();
		//$attr['inset']			= 0;
		$attr['width'] 			= $tree_width;
		$attr['height'] 		= $height;
		
		// font size
		$font_height = 24;
		
		$attr['font_height'] 	= $font_height;
		$attr['line_width'] 	= 1;
		
		// Don't draw labels (we do this afterwards)
		$attr['draw_leaf_labels'] = true;
		$attr['draw_internal_labels'] = false;
		$attr['draw_scale_bar'] = false;
		
		$td = NULL;
		
		if ($t->HasBranchLengths())
		{
			$td = new PhylogramTreeDrawer($t, $attr);
		}
		else
		{
			$td = new RectangleTreeDrawer($t, $attr);
		}
		
		
		$td->CalcCoordinates();	
		$port = new SVGPort('', $width, $height, $font_height, false);
		
		$port->StartGroup('tree', true);
		$td->Draw($port);
		$port->EndGroup();
		
		
		$svg = $port->GetOutput();
		
		echo '<a href=".">Home</a>';
		
		
		echo '<h1>Bayesian trees</h1>';
		echo '<p>When we do a Bayesian phylogenetic analysis we use a technique called Markov Chain Monte Carlo (MCMC)
		to find the trees with the highest posterior probability. This method can generate millions of slightly different trees
		as it converges on best trees. Because every combination of tree shape and branch length has a different
		posterior probability, typically we summarise them by counting how often each group of species occurs in each tree. How many
		times each group appears in the set of MCMC trees is the posterior probability of that group being true (given the underlying model and data).
		Clicking <a href="bootstrap.php?tree_num=' . $next . '">Next</a> below will show another tree generated by the MCMC method. As you click on next, keep track of what groups appear in
		the trees. Are they always the same?</p>';
		
		echo '<h2>Tree ' . ($tree_num * 500) . '</h2>';
		
		
		echo $svg;
		echo '<br/>';
		echo '<a href="bayes.php?tree_num=' . $next . '">Next</a>';
		
		
		
		exit();
	}
	$count++;
}





?>
